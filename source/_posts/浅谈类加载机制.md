---
title: 浅谈类加载机制
date: 2018-03-30 09:54:10
tags: 
	- Java
	- JVM
---
看了周志明的`《深入理解Java虚拟机》`感觉理解了一些JVM的知识，记笔记！记笔记！
为什么先从类加载机制开始讲呢，因为Java类在JVM中存储首先要使用类加载器加载类，可以有顺序的了解Java类从.java文件编译成.class字节码文件，最后存储在JVM中的数据结构中的整个流程。
![类加载机制](https://i.imgur.com/PdoX54n.png)
## 加载时期
首先.java文件被编译成.class文件后，会在什么时期对其进行加载呢？
JVM规范中规定“有且只有”5种场景会触发类的初始化，加载自然在初始化之前。  
1. 遇到`new`(实例化对象)、`getstatic`(读取静态字段)、`putstatic`(设置静态字段)、`invokestatic`(调用类的静态方法)字节码指令。
2. 调用`java.lang.reflect`包的方法对类进行反射调用。
3. 初始化类时，其父类未被初始化，先对其父类进行初始化。
4. JVM启动时，初始化用户指定一个执行的主类(包含main方法)。
5. JDK1.7动态语言支持，`java.lang.invoke.MethodHandle`实例解析的结果`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，且方法句柄对应的类未被初始化，需先触发对应类的初始化。
以上5种为主动引用，除此之外的所有应用方式都不会触发类的初始化，称为被动应用。常见的列子如：
1. 通过子类的引用父类的的静态字段，不会触发子类的初始化，只会初始化子类。
2. 通过数组定义来应用类，不会触发类的初始化。
3. 应用类的常量，常量在编译阶段会存储在类的常量池中，调用它并不会应用到常量所属的类。

### 加载方式
JVM是通过“类全限定名”来获取二进制流。获取方式有：
1. 从zip包中读取，如`JAR(Java Archive File),WAR(Web Archive File),EAR(Enterprise Archive File)`文件。
2. 程序运行时生成的，如动态代理技术在`java.lang.reflect.Proxy`中，使用`ProxyGenerator.generateProxyClass`来为特定接口生成$Proxy的代理类的二进制字节流。
3. 其他格式文件生成，如`JSP`应用。
4. 网络中获取，如`Applet`应用。
5. 数据库中获取，如中间件服务器(SAP Netweaver)选择把程序安装到数据库中，完成代码在集群的分发。

获取字节流阶段可以使用系统提供的的类加载器，也可以使用开发人员自己定义的类加载器控制字节流的获取方式。类加载器将获取的字节流描述的静态存储结构转换为JVM中方法区的运行时数据结构，即虚拟机外部的二进制字节流按照虚拟机的存储格式存储在JVM的方法区中，在JVM堆中生成一个代表这个类的`java.lang.Class`对象作为方法区这些数据的入口。

## 验证

在将字节流以JVM的数据格式存储在JVM中之前，必须对其进行验证，主要目的是确保class文件的字节流的信息符合虚拟机要求，并不会对虚拟机产生危害。  
主要包括四个验证过程：
1. 文件格式验证，验证class文件格式规范，例如class文件是否以魔数`0xCAFEBABE`(咖啡宝贝)开头，版本是否在虚拟机的处理范围之内，通过此阶段的字节流才会进入方法区进行存储，后面的验证是对方法区的存储结构进行的。
2. 元数据验证，验证字节码的语义，保证符合Java语言规范，例如验证该类是否有父类，是否继承了不允许被继承的类。
3. 字节码验证，验证分析类的方法体，程序语义是否合法符合逻辑。
4. 符号码验证，验证通过符号描述的类名，是否可以找到对应的类，字段方法的访问性(`private, protected, default,public`)。

## 准备

准备阶段是正式为static修饰的类变量（不包括类的实例变量）分配方法区的内存并设置初始值的阶段。初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为:`private static int value = 110;`那变量value在准备阶段后的初始值为0而不是110,而把value赋值为110的putstatic指令是程序被编译之后，存放在类构造器`<clinit>()`方法之中，所以value赋值为110发生在初始化阶段，还会有一些“特殊情况”例如字段属性表中存在`ConstantValue`，编译时javac会将value生成`ConstantValue`属性，在准备阶段就会将其赋值。

## 解析

解析阶段是虚拟机将常量池内的符号引用替代为直接引用的过程。符号引用是一组符号描述所引用的目标，只要使用时能无歧义地定位到目标即可。符号引用于虚拟机内存布局无关，引用的目标的不一定加载到内存中。而直接引用是指可以指向目标的指针，相对偏移量或者一个简洁定位到目标的句柄，与虚拟机内存布局有关。解析的动作主要针对类或接口，字段，类方法，接口方法，方法类型，方法句柄。

## 初始化

初始化阶段是执行类构造器`<clinit>()`方法的过程，`<clinit>()`方法是由编译器自动收集所有类变量的赋值动作个静态语句块(`static{}`)合并产生的，收集顺序有源代码文件出现的顺心决定，静态语句块只能访问定义在静态语句块之前的变量，定义在之后的变量，在前面的语句块中可以赋值，但是不能访问。


> 本文标题：浅谈类加载机制  
> 发布时间：2018年4月1日  
> 更新时间：2018年4月1日
> 许可协议：[署名-非商用-相同方式共享4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


